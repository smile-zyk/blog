前情提要：[整数的表示与编码](https://www.cnblogs.com/z-y-k/p/11891104.html)   
了解了整数的编码方式和不同数据类型的表示范围之后，我们来了解一下整数是如何运算的：  
# 整数运算
## 无符号数加法
考虑两个w为的无符号整数x、y，他们的编码范围都为[0,2<sup>w</sup>-1],那么x+y的范围为[0,2<sup>w+1</sup>-2],显然两个无符号数加法的结果是可能发生溢出的。  
为了舍弃多出来的位数，我们可以使用前面提到的截断的方法，把结果截断成w位就是溢出后舍弃进位的结果。  
我们将无符号加法表示为+<sup>u</sup><sub>w</sub>：  
```math
x+^u_wy=\left\{
\begin{array}{rcl}
x+y       &      & {x+y<2^w}(正常)\\
x+y-2^w     &      & {2^w \leq x+y < 2^{w+1}}(溢出)\\
\end{array} \right.
```
通常，说一个算术溢出，是指完整的整数结果不能放到数据类型的字长限制中去。
CSAPP中还给出了一个判断结果是否溢出的方法：
```math
对在范围0 \leq x,y\leq UMax_w中的x和y，令s=x+^u_wy。则对计算结果s，当且仅当s<x(或者等价地s<y)时，发生了溢出。  
```
### 无符号数求反
知道了加法后，我们只要知道一个数如何求反就能把加法化成加法：
```math
-^u_wx=\left\{
\begin{array}{rcl}
x      &      & {x=0}\\
2^w-x     &      & {x>0}\\
\end{array} \right.
```
求反或者说求加法逆元的方法就是让两个结果的和为0。
## 补码加法(有符号数)
给定两个w位的补码表示的有符号数x、y，范围为[-2<sup>w-1</sup>,2<sup>w-1</sup>-1],x+y的范围为[-2<sup>w</sup>,2<sup>w</sup>-2]，和有符号数一样准确表示这个范围的数需要w+1位的补码。  
另一方面，和截断一样，补码的加法和有符号数的加法其实从位模式上看也是一样的，将两个数相加后截断，然后将位模式解释为补码，得到的结果就是补码加法的结果：
 ```math
x+^t_wy=\left\{
\begin{array}{rcl}
x+y-2^w     &   &2^{w-1} \leq x+y(正溢出)\\
x+y       &      & {-2^{w-1} \leq x+y<2^{w-1}}(正常)\\
x+y+2^w     &      & {x+y < -2^{w-1}}(负溢出)\\
\end{array} \right.
```
同样的，CSAPP中也给出了一个判断结果是否溢出的方法:

```math
对满足TMin_w\leq x,y\leq TMax_w 的x和y,令s=x+^u_wy。当且仅当x>0,y>0,但s\leq 0时，计算s发生了正溢出，当且仅当x<0,y<0,但s\geq 0时发生了负溢出。
```
### 补码的非
和无符号数求反一样，补码的非实际上就是求加法逆元，这里直接给出公式：  
```math
-^t_wx=\left\{
\begin{array}{rcl}
TMin_w      &      & {x=TMin_w}\\
-x&      & {x>TMin_w}\\
\end{array} \right.
```
### 补码和无符号数编码都满足阿贝尔群
不能使用x+y-y==x的方法来判断x+y无论是否溢出，最后的结果都是x，这是因为补码和无符号数都满足阿贝尔群。

## 无符号数和补码的乘法
和上面一样溢出就截断，补码可以先看成无符号编码，算出结果后转换成补码即可(无符号和补码乘法运算的位级表示都是一样的)，不赘述。
无符号乘法公式:
```math
x*^u_wy=(x•y) mod 2^w
```
补码乘法公式:
```math
x*^t_wy=U2T_w((x•y) mod 2^w)
```
## 整数乘以常数
我们可以使用移位运算结合加法与减法进行整数与常数的乘法。  
原理为：**w位变量x<<k(0<=k<w)的值等于x * 2<sup>k</sup>**。  
即使移位后的结果产生溢出也不会影响最后的结果(如果溢出说明正常相乘的结果也会溢出)。  
而任何整数都可以由2的幂组合而成，故我们可以用移位结合加法来进行乘法运算，例如14可以写成14=2<sup>3</sup>+2<sup>2</sup>+2<sup>1</sup>。故x*14=(x<<3)+(x<<2)+(x<<1)。  
而对于一个形如[(0...0)(111)(0...0)]的位向量，考虑从位位置n到位位置m的连续的1(n>=m)。我们可以用2<sup>n+1</sup>-2<sup>m</sup>来代替2<sup>n</sup>+...+2<sup>m</sup>。例如对于14[(0...0)(111)(0)]来说,n=3,m=1,即14可以写作2<sup>4</sup>-2<sup>1</sup>，故x *14亦可以写作(x<<4)-(x<<1)。  
使用正常的乘法还是使用上述运用移位和加减的方法取决于这些指令的相对速度，当乘数的数额可以使用少量2的幂次相加或相减的得到时，我们(编译器)一般使用这种方法。

## 整数除以2的幂
和整数乘法一样，整数的除法也可以使用这一属性，但仅限于除以2的幂(书中并没有明确说明，但是右移代替除法会产生一定的误差，一次两次右移结果相加减可能没什么问题，多了的话误差肯定会越来越大，所以我估计用右移代替除法应该仅限于2的幂)。  
**w位变量x>>k(0<=k<w)的值等于[x / 2<sup>k</sup>] (向零取整)**。  
由于整数除法会产生小数位，我们需要把结果转换为整数，这就涉及到了**取整操作**。  
取整分为向上取整(⌈x⌉)和向下取整(⌊x⌋)，顾名思义，向上取整就是找比该数大的最小整数，向下取整就是找比该数小的最大整数。而整数除法则要求我们向零取整，即：如果该数大于0就向下取整，如果该数小于0就向上取整。  
- 对于无符号数右移(逻辑右移)，我们可以确定证明出其结果一定是向下取整的(证明过程略)。  
- 对于补码右移(算术右移)，正数右移和无符号数一样是向下取整的(证明过程略)。  
- 而对于补码的负数情况并不满足向零取整的要求---负数右移依然是向下取整的。  
- 为了解决这个问题我们需要在负数作除法时为其加上一个偏置(2<sup>k</sup>-1)。具体原理为对于整数x和y(y>0),⌈x/y⌉=⌊(x+y-1)/y⌋。这里的y为2<sup>k</sup>。
- 综上所述：对于使用算数右移的补码机器，C表达式为(x<0?x+(1<<k)-1:x)>>k。
