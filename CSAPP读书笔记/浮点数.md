# 2.4.1二进制小数
二进制只能表示分母为2的幂的小数，如1/2(0,1),1/4(0.01)等，而对于分母为非2的幂的小数则无法精确表示，如1/5,5/7。如果要用有限二进制位表示这些分母非2次幂的实数必定要损失精度，增加二进制表示的长度可以提高表示的精度。

> 真实案列  
1991年海湾战争，美军的爱国者导弹拦截飞毛腿失败，失败的原因正是由于浮点数的精度问题，爱国者弹道系统中内置的时钟计数器每0.1秒就会加一次来确定时间，系统程序采用24位精度的二进制数来近似的表示0.1。该系统已经运行了大约100个小时，这没什么问题，通常情况下这种误差可以忽略不计。但是在计算导弹的发射时间时，由于系统的更新导致，爱国者导弹的系统升级了读取方式，现在它可以得到精确的时间，而有的函数并没有使用精确的读取方式，导致两次读取发生了偏差，这样的误差因为长时间的系统运行而放大。最终爱国者导弹未能成果拦截飞毛腿。

# 2.4.2IEEE754标准
## IEEE
电气和电子工程师协会（IEEE，全称是Institute of Electrical and Electronics Engineers）是一个包括所有电子和计算机技术的专业团体。1985年，IEEE提出IEEE754标准来表示浮点数。
## 具体表示
IEEE754标准主要由三个部分来组成浮点数：
- 符号(sign):s决定浮点数的正负。  
- 尾数(siganificand):M表示二进制小数
- 阶码(exponent):E的作用是对浮点数加权。
- V=(-1)<sup>s</sup> * M * 2<sup>E</sup>。

对于单精度浮点数来说，符号位占1位，阶码占8位，尾数占23位。  
对于双精度浮点数来说，符号位占1位，阶码占11位，尾数占52位。

根据阶码值的不同，浮点数的具体值的计算方法也有所不同，主要分为3种情况(以32位单精度为例):

### 规格化的值
当阶码的位向量不全为0，也不全为1时，我们就把它看作是规格化的值。  
规格话的值中，阶码E的值实际上应该为上面阶码的值再减去一个偏置，该偏置位2<sup>k-1</sup>-1，即E=e-2<sup>k-1</sup>-1。那么阶码的实际范围应该位-126~+127。  
而尾数的值解释为1.f<sub>n-1</sub>f<sub>n-2</sub>...f<sub>0</sub>,即把它看成小数二进制表示并加1。这使得如此表示的小数多获得了一位精度。
#### 为什么要规格化
一个实数可以写成多种的浮点格式，为了是浮点数的编码是唯一的，并且提高浮点数的表示精度，我们规定：当尾数的值不为0时，尾数域的最高有效位应为1，这称为浮点数的规格化表示。否则以修改阶码同时左右移小数点位置的办法，使其变为规格化数的形式。  
如此的话尾数域的最高位总是1，故我们不将其存储，默认规格化浮点数的尾数为1.f<sub>n-1</sub>f<sub>n-2</sub>...f<sub>0</sub>。

### 非规格化的值
当阶码的位向量全为0的时候，阶码实际值为2-2<sup>k-1</sup>，尾数为0.f<sub>n-1</sub>f<sub>n-2</sub>...f<sub>0</sub>。

### 特殊值
当阶码的位向量全为1的时候，如果尾数的位向量全为0，看作无穷，当s=0时为负无穷，当s=1时为正无穷。  
如果尾数的位向量不全为0，看作NaN(即非数)。

### IEEE754的特性
- 有两种零的表示，一种为+0([0000.....0000])，一种为-0([1000...0000])。  
- 这种编码所表示的实数，并不是均匀分布的---越靠近原点处它们越稠密。
- 如果我们把位向量看作无符号数从小到大排列，我们会发现其对应的浮点数也是从小到大排列的，这不是偶然，IEEE格式如此设计就是为了浮点数能过使用整数排序函数来进行排序。

## IEEE754浮点数的加减法
设有两个浮点数x和y,它们分别为  
x = Mx * 2^Ex  
y = My * 2^Ey  
其中Ex和Ey分别为数x和y的阶码,Mx和My为数x和y的尾数。  
两浮点数进行加法和减法的运算规则是  
设 Ex小于等于Ey，则 x±y = (Mx*2^(Ex－Ey)±My) *2^Ey,  
完成浮点加减运算的操作过程大体分为四步：  
1. 0 操作数的检查；  
2. 比较阶码大小并完成对阶；  
3. 尾数进行加或减运算；  
4. 结果规格化并进行舍入处理。  
-  操作数检查  
浮点加减运算过程比定点运算过程复杂。如果判知两个操作数x或y中有一个数为0,即可得知运算结果而没有必要再进行后续的一系列操作以节省运算时间。0操作数检查步骤则用来完成这一功能。  
- 比较阶码大小并完成对阶  
两浮点数进行加减，首先要看两数的阶码是否相同，即小数点位置是否对齐。若二数阶码相同，表示小数点是对齐的，就可以进行尾数的加减运算。反之，若二数阶码不同，表示小数点位置没有对齐，此时必须使二数阶码相同，这个过程叫作对阶。  
要对阶，首先应求出两数阶码Ex和Ey之差，即  
△E = Ex－Ey  
若△E=0,表示两数阶码相等，即Ex=Ey；若△E>0,表示Ex>Ey；若△E<0,表示Ex<Ey。    
当Ex≠Ey 时，要通过尾数的移动以改变Ex或Ey,使之相等。原则上，既可以通过Mx移位以改变Ex来达到Ex=Ey,也可以通过My移位以改变Ey来实现Ex=Ey。但是，由于浮点表示的数多是规格化的，尾数左移会引起最高有效位的丢失，造成很大误差。尾数右移虽引起最低有效位的丢失，但造成误差较小。因此，对阶操作规定使尾数右移，尾数右移后阶码作相应增加，其数值保持不变。显然，一个增加后的阶码与另一个阶码相等，增加的阶码的一定是小阶。因此在对阶时，总是使小阶向大阶看齐，即小阶的尾数向右移位(相当于小数点左移）每右移一位，其阶码加1,直到两数的阶码相等为止，右移的位数等于阶差△E。  
- 尾数求和运算  
对阶结束后，即可进行尾数的求和运算。不论加法运算还是减法运算，都按加法进行操作，其方法与定点加减法运算完全一样。  
- 结果规格化  
在浮点加减运算时，尾数求和的结果也可以得到11.ф…ф或10.ф…ф，即两符号位不等，这在定点加减法运算中称为溢出，是不允许的。但在浮点运算中，它表明尾数求和结果的绝对值大于1,向左破坏了规格化。此时将运算结果右移以实现规格化表示，称为向右规格化。规则是：尾数右移1位，阶码加1。当尾数不是1.M时需向左规格化。  
- 舍入处理  
在对阶或向右规格化时，尾数要向右移位，这样，被右移的尾数的低位部分会被丢掉，从而造成一定误差，因此要进行舍入处理。  
在IEEE754标准中，舍入处理提供了四种可选方法：  
向偶数舍入。类似与“四舍五入”，但又有不同的地方，如果这个数可能要舍入的两个结果的中间数，如:2.5是2和3的中间数。那么就要向偶数舍入(二进制中的偶数只有0)。例如，尾数超出规定的23位的多余位数字是10010,多余位的值超过规定的最低有效位值的一半，故最低有效位应增1。若多余的5位是01111,则简单的截尾即可。对多余的5位10000这种情况，就向偶数舍入:若最低有效位现为0,则截　尾；若最低有效位现为1,则向上进一位使其变为 0。  
朝0舍入 即朝数轴原点方向舍入，就是简单的截尾。无论尾数是正数还是负数，截尾都使取值的绝对值比原值的绝对值小。这种方法容易导致误差积累。  
朝+∞舍入 对正数来说，只要多余位不全为0则向最低有效位进1；对负数来说则是简单的截尾。
朝－∞舍入 处理方法正好与 朝+∞舍入情况相反。对正数来说,只要多余位不全为0则简单截尾；对负数来说，向最低有效位进1。  
- 溢出处理  
浮点数的溢出是以其阶码溢出表现出来的。在加\减运算过程中要检查是否产生了溢出：若阶码正常，加（减）运算正常结束；若阶码溢出，则要进行相应处理。另外对尾数的溢出也需要处理。  
阶码上溢 超过了阶码可能表示的最大值的正指数值，一般将其认为是+∞和－∞。  
阶码下溢 超过了阶码可能表示的最小值的负指数值，一般将其认为是0。  
尾数上溢 两个同符号尾数相加产生了最高位向上的进位，将尾数右移，阶码增1来重新对齐。  
尾数下溢 在将尾数右移时，尾数的最低有效位从尾数域右端流出，要进行舍入处理。  

## IEEE754浮点数运算的一些特殊情况
- √-0.0=-0.0=0.0
- -Inf <负的规约浮点数数<负的非规约浮点数< -0.0 = 0.0 <正的非规约浮点数<正的规约浮点数< Inf\
- -Inf = -Inf, Inf = Inf
- NaN与任何的比较结果都为假可以用if(x!=x)来判断是否为NaN
> 会产生NaN的操作  
> - 操作数中至少有一个是 NaN 的运算  
> - 未定义操作   
> 1. 下列除法运算：0/0、∞/∞、∞/−∞、−∞/∞、−∞/−∞  
> 2. 下列乘法运算：0×∞、0×-∞  
> 3. 下列加法运算：∞ + (−∞)、(−∞) + ∞  
> 4. 下列减法运算：∞ - ∞、(−∞) - (−∞)  
> - 产生复数结果的实数运算。例如：   
> 1. 对负数进行开方运算  
> 2. 对负数进行对数运算  
> 3. 对比-1小或比+1大的数进行反正弦或反余弦运算  

## IEEE754浮点运算的一些属性
- 浮点数加法和乘法不具有结合性
- 浮点数加法和乘法具有单调性(整数加法不具有)

## 其他表示法
在考研的计算机组成原理课程上经常会出一些非IEEE754标准的题目，比如说用移码来作阶码，用补码来做尾数，有一些坑在这里记录一下：  
### 关于移码
为了使阶码能在比较时能够使其位向量呈现和其真值一样的从小到大排列，我们引入了移码：  
把其位向量的真值减去2<sup>k-1</sup>得到移码。  
如对于4位的按移码编码的位向量[0000]的值为0-8=-8、[1000]为8-8=0。  
移码可以看作补码符号位取反后的结果。  
注意：IEEE754标准中的阶码编码方式可以看作移码的编码值+1。
### 补码作尾数
补码的符号位为编码的一部分，代表负的权重。  
为了使其规格化，我们必须要使规格化浮点数尾数的补码最高有效位与符号位相反，如果符号位为1那么尾数最高位为0，如果符号位为0那么尾数最高为1（这种特性是因为补码的编码格式造成的，负数的补码拓展需要在前面置1，如果想要对其规格化，那么必须找到第一个不为1的位）。  