# 汇编语言的种类
汇编语言本质上是机器语言的助记符，所以针对不同的机器(CPU)汇编语言的类型也不同自然也不同，主要的汇编语言有ARM汇编和IBM PC汇编。  
IBM PC汇编也就是Intel的汇编，因为IBM最早推出PC机，后来的体系很多都要和它兼容，所以也使用了相同的汇编语言。  
CPU只限定了机器码，作为开发语言的汇编，其实还和编译器息息相关。IBM PC 汇编主要有两种格式：Intel格式和AT&T格式。  
Intel格式又有NASM和MASM，NASM是开源的，支持多平台。而MASM是微软开发的支持windows。  
AT&T格式只要用于UNIX系统，GUN汇编器默认使用的是AT&T格式。  
我在学习中主要阅读了两本书《深入理解计算机系统(CSAPP)》以及《X86汇编语言:从实模式到保护模型》,前者使用了AT&T格式，后者使用了NASM作为编译器。  
在本博客中主要使用AT&T汇编语言格式，并在对应位置注明另一种汇编器的写法。  

# 先导知识
## x86处理器中的寄存器
- 16bit CPU中的寄存器   
最早的8086处理器(16bit)中有16个寄存器，每个寄存器有16位，其中寄存器中的低位可以单独使用。  

![QQ截图20210304143212.png](https://i.loli.net/2021/03/04/4wGZhM9U3gr7DBV.png)  
- 32bit CPU中的寄存器  
后来Intel开发了80386处理器(32bit)，出于兼容性的考虑，原先16位的寄存器被保留下来并加以拓展变成了32位。  

![QQ截图20210304143749.png](https://i.loli.net/2021/03/04/S9xw6sCoFpRP38m.png)  
- 64bit CPU中的寄存器  
再后来，处理器扩展到了64位，除了拓展原先的32位寄存器以外，Intel还添加了8个新的寄存器(%r8~%r15)。  

![QQ截图20210304144323.png](https://i.loli.net/2021/03/04/1nxf62RJhQXPOjL.png)

### x86-64处理器中不同寄存器的功能
![QQ截图20210304144712.png](https://i.loli.net/2021/03/04/BwsHKVyWR4hZkCQ.png)  
![QQ截图20210304144820.png](https://i.loli.net/2021/03/04/iVyoslIzmb2eTFZ.png)

Note:
- %rax - 存储函数的返回值
- %rsp - 存储程序栈的结束位置
- %rdi,%rsi,%rdx,%rcx,%r8,%r9 - 存储函数的参数(按顺序存储6个参数)

> AT&T与Intel格式  
在AT&T中的寄存器在使用时需要在其名称前加上%，而NASM格式中则不需要。


### 调用者保存寄存器和被调用者保存寄存器(Caller-saved register&Callee-saved register)
在汇编语言中不同函数有时会使用同一个寄存器，当一个函数在执行时调用了另一个函数并且这两个函数都使用了同一个寄存器进行操作，我们就需要把这个寄存器的值再被调用时进行保存(存入栈中)，具体有两种做法：  
1. 在调用另一个函数的函数内先进行存储，这类寄存器被称为调用者存储寄存器，在写一个要调用会改变调用者存储寄存器的函数时，我们再call这个函数前需要先将这个寄存器中压栈，调用结束后再弹出。
2. 在被调用的函数内进行存储，这类寄存器被称为被调用者存储寄存器，在写一个要使用被调用者存储寄存器的函数时，我们需要在函数开始时先将寄存器内容压栈，函数结束时再弹出。  

![QQ截图20210306144650.png](https://i.loli.net/2021/03/06/rdf8nHepDNiq3l1.png)  

![](https://i.loli.net/2021/03/04/W7HUwAFhkJQdvDl.png)

## x86处理器中的数据类型和长度
![QQ截图20210304150943.png](https://i.loli.net/2021/03/04/EFM5ehSRgN97cVJ.png)  

由于Intel最先开发的处理器8086是16bit的，所以在Intel的体系中一般把16bit称为一个字(word)，一个字即为两个字节byte。  
> AT&T与Intel格式  
在AT&T格式汇编中需要在指令末尾添加后缀来表明其操作的数值位长(如movb,movw)，但在NASM汇编中则不需要。

# 指令
## 指令格式
大部分汇编语言的指令可以分为操作码和操作数(有些指令没有操作数)。  

![QQ截图20210304182403.png](https://i.loli.net/2021/03/04/2GsbWZvy7dCYPL1.png)  
而操作数又可以分为源操作数和目的操作数(例如数据传送指令就需要两个操作数来指明把什么地方的操作数放到什么地方)。  
> AT&T和Intel格式  
AT&T格式中源操作数在前，目的操作数在后。如(movq $10 %rax)  
而Intel格式中源操作数在后，目的操作数在前。如(mov rax 10)  

### 操作数
不同指令的操作数大致可以分为三类，分别为立即数、寄存器、以及内存引用。  

- 立即数  
即一个整数，书写需要满足C语言标准(如16进制数要在前面加0x)
> AT&T与Intel格式  
在AT&T格式中，立即数需要在前面加上一个$符号，Intel格式则不需要。
- 寄存器  
即寄存器，在64位的机器上，不仅64位的寄存器可以操作，32位、16位甚至8位的寄存器都可以操作。
- 内存引用  
即引用内存中相应位置的数据，具体(AT&T)写法如下面两张图片所示(需要特别注意不带$的立即数和带了括号的寄存器代表的是内存引用(仅限AT&T格式))。  

![QQ截图20210306145312.png](https://i.loli.net/2021/03/06/kJbvorNEgBOwiXl.png)  
![QQ截图20210306151113.png](https://i.loli.net/2021/03/06/GNlRADUJqTLxXi5.png)  
> 关于比例因子为什么只能是1,2,4,8  
这是因为变址寄存器主要是为了访问数组元素而设计，变址寄存器中主要存放的是数组下标，而不同数据类型的数组中存放的元素位长是不一样的(具体见上面的数据类型)，数据类型一般只有1,2,4,8(单位为byte)这些长度，所以比例因子只能使用1,2,4,8。  

## 数据传送指令
mov指令(即数据传送指令)，在AT&T格式中使用后缀来指明传输的数据大小。  
  
![QQ截图20210306151641.png](https://i.loli.net/2021/03/06/5rglQJASdMPHV2T.png)  
  
mov指令一般有两个操作数，一个是源操作数，一个是目的操作数，其中目的操作数不能是一个立即数，并且在x86-64中不能直接将一个内存中的数据转移到另一个内存(即两个操作数不能都是内存引用)。  
如果要将一个内存引用写入另一个内存，我们需要先把内存中的数据传送到一个寄存器，再把这个寄存器中的数据传送到内存。  
  
![QQ截图20210306152059.png](https://i.loli.net/2021/03/06/pvx1LB9wD5Saylc.png)  
  
Note:  
在x86-64中有几个奇怪的规定:
1. 当使用movq指令的源操作数为立即数时，该立即数必须是32位补码，并且在传入目的位置时将该32位补码进行符号拓展。  
2. 任何对寄存器生成32位值的指令都会自动把该寄存器的高32位置为0，如(movl $-1 %eax)不仅会把rax的低32位置为FFFFFFFF，同时会将该寄存器的高32位置为0，此时该寄存器的内容应该为00000000FFFFFFFF。  
  

为了解决第一规定带来的问题，x86-64中引入了一个名为**movsbsq**的指令，他的操作数可以是任意64位数，但是目的操作数只能是64位寄存器。  
  
当源操作数的位长小于目的操作数时，我们需要对目的操作数剩余的字节进行零拓展或者符号拓展。  
- 零拓展数据传送指令  

![QQ截图20210306154258.png](https://i.loli.net/2021/03/06/adjUWMYvVE7noSA.png)  
零拓展数据传送指令一共有5条，其中z代表zero表示零拓展，后面的两个字符为源操作数的位长和目的操作数的位长。  
零拓展数据传送指令缺少一条从4字节拓展到8字节的指令，这是由于前面提到的一个规定，即：任何对寄存器生成32位值的指令都会自动把该寄存器的高32位置为0。所以不需要这条指令movl就可以自动进行零拓展。  

- 符号位拓展数据传送指令  

![QQ截图20210306155022.png](https://i.loli.net/2021/03/06/OMGPTehZcRUKd2o.png)  
符号位拓展数据传送指令一共有6条，其中s代表sign表示符号位拓展，后面的两个字符为源操作数的位长和目的操作数的位长。  
除了6条基本的符号位数据传送指令外，还有一条**cltq**指令，他的作用是将%rax的低32位符号拓展为64位。  




