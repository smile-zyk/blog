# 第二章：信息的表示和处理
现代计算机存储和处理的信息以二进制表示，一个二进制数称为一个比特（bit）。  
单个的位并没有什么作用。当把位组合起来，再加以解释，我们就可以表示任何有限集合的元素。（如我们可以用位组编码非负数，或者使用标准的字符码对文档中的字符进行编码，或者通过一些方式编码负数和实数近似值）  
本章我们主要研究三种重要的数字表示：
- **无符号（unsigned）编码** 基于传统的二进制表示法。
- **补码（two’s—complement）编码** 是表示有符号整数的最常见的方式。
- **浮点数（float—pointing）编码** 是表示实数的科学计数法的以2为基数的版本。  

计算机对数字的表示是基于有限数量的位，所以当结果太大以至于不能表示时。某些运算就会导致**溢出（overflow）**  

整数的溢出时往往会产生负数，但另一方面在计算机中对整数的运算满足人们所熟知的真正整数运算的许多性质。
> 如200 * 300 * 400 * 500在大多数计算机上（使用32位表示数据类型int）的计算结果为-884901888。这显然违背了整数运算的特性。  
但是计算下面运算时虽然结果肯定不对，但是结果却都是相同的，这说明计算机在计算整数时满足很对人们熟知的运算性质。
> - （500 * 400）*（300 * 200）
> - （（500 * 400）* 300）* 200）
> - （（200 * 500）*300） * 400    
>   
> 上面运算的结果都为-884901888。
  
浮点数的溢出(暂略)  

### 为什么要研究计算机中数字的实际表示  
- 了解可以表示的值的范围和不同的算术运算的属性，可以使编写的程序能在全部数值范围内正确工作。  
- 帮助程序员写出可以跨越不同机器、操作系统和编译器的程序。  
- 防止黑客利用数值漏洞攻击你的设备。  
- 为下一章学习机器级变成奠定基础。  
  
> 小知识：C语言的历史及其命令行编译  
1969-1963年Ritchie在贝尔实验室开发了C语言，这也是C语言的第一个版本。  
1989年美国国家标准协会(ANSI)推出了ANSI C标准，对最初的版本做了重大的修改，尤其是函数声明的方法。K&R为此编写了《C程序设计语言》第二版，这本书至今仍被公认为关于C语言最好的参考手册之一。  
1990年，国际标准化组织(ISO)接替了对C语言进行标准化的任务，推出了一个几乎和ANSI C一样的版本，称为“ISO C90”。  
1999年，ISO又对C语言做了更新，推出"ISO C99"，在这一版本中，引入了一些新的数据类型，对非英语字符提供了支持。  
2011年，ISO推出“ISO C11”，添加了更多的数据类型和特性。  
在GUN编译器套装(GNU Compiler Collection，GCC)可以基于不同的命令行选项，依照不同版本的C语言规则来编译程序，如下图：  
> C版本 | GCC命令行选项
> ---|---
> GNU 89 | 无，-std=gnu89
> ANSI,ISO C90 | -ansi,-std=c89
> ISO C99| -std=c99
> ISO C11| -std=c11
> 如：使用C11来编译程序prog.c，我们就使用命令行：  
`linux> gcc -std=c11 prog.c`
## 2.1 信息存储
大多数计算机使用8位的块，或者字节(byte)，作为最小的可寻址的内存单位。(1byte=8bit)  
机器级程序将内存视为一个非常大的字节数组，称为虚拟内存(virtual memory)。内存中的每个字节都由一个唯一的数字来标识，称为它的地址，所有可能的地址集合称为虚拟内存地址空间(virtual address space)(虚拟地址空间是展现给机器级程序的概念性映像)。  
C语言中一个指针的值都是某个存储块的第一个字节的虚拟地址。C语言编译器还把每个指针和类型信息联系起来，这样就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。  
### 2.1.1 十六进制表示法
为了简洁有效的表示和描述位模式，我们使用十六进制(hexadecimal)，简写为"hex"来表示位模式。使用'0'~'9'以及'A'~'F'来表示16个可能的值。一个字节的值域为00<sub>16</sub>~FF<sub>16</sub>。  
> 当值x是2的非负整数n次幂时，也就是x=2<sup>n</sup>，我们可以很容易地将x写成十六进制形式，只要记住x的二进制表示就是1后面跟n个0.十六进制数字0代表四个二进制0。  
  
十六进制转换为十进制需要反复除以16后记下余数，然后倒着写出即可。  

### 2.1.2 字数据大小
每台计算机都有一个字长，指明指针数据的标称大小。因为虚拟地址是以这样一个字来编码的，所以机器字长决定的最重要的系统参数就是虚拟地址空间的最大大小。如对于一个64位的机器来说，虚拟地址的范围是0~2<sup>64</sup>。  
> 32位字长限制的虚拟地址空间为4千兆字节，64位字长的虚拟地址空间为16EB，大约是1.84×10<sup>19</sup>字节。  
  
大多数64位机器兼容32为程序，只需要在指令中加入`-m32`即可。  
不同机器字长对不同的数据类型分配不同的字节数。如下图:  

有符号 | 无符号 | 32位 | 64位 
---|---|---|---
[signed]char | unsigned char | 1 | 1
short | unsigned short | 2 | 2
int | unsigned | 4 | 4
long | unsigned long | 4 | 8
int32_t | uint32_t | 4 | 4
int64_t | uint64_t | 8 | 8
char * |  | 4 | 8
float| | 4 | 4
double |  | 8 | 8
从上表我们可以看出有些数据类型的确切字节数依赖于程序是如何被编译的。  
为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化(如：int32_t和int64_t)。  
程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植性的一个方面就是使程序对不同的数据类型的确切大小不敏感(比如，在32位机器时代，许多程序员使用int类型存储一个指针，然而这在一台64位机器上是不被允许的)。  
### 2.1.3 寻址和字节顺序  
在几乎所有机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。  
某些机器选择在内存中按照从最低有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序表存储。前一种规则--最低有效字节在最前面的方式，称为小端法(little endian)。后一种规则--最高有效字节在最前面的方式，称为大端法(big endian)。  
假设我们要存储一个整型变量到地址0x100处，它的十六进制为0x01234567.地址范围0x100~0x103的字节顺序依赖于机器的类型。在内存中的存储方式如下：  
**大端法：**
...|0x100|0x101|0x102|0x103|...
---|:---:|:---:|:---:|:---:|---
...|01|23|45|67|...
**小端法：**
...|0x100|0x101|0x102|0x103|...
---|:---:|:---:|:---:|:---:|---
...|67|45|23|01|...
大多数Intel兼容机都只用小段模式。另一方面，IBM和Oracle的大多数机器则是按大端模式操作。  
许多比较新的微处理器是双端法(bi-endian)，这种情况下一般选择了特定的操作系统，字节顺序也就固定下来了。  
对于大多数应用程序，使用大端法还是小端法并没有说明影响，不过有些时候字节顺序会成为问题：  
1. 在不同数据类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则。  
2. 当阅读表示整数数据的字序列时字节顺序也很重要。这通常发生在检查机器级程序时。  
3. 编写规避正常的类型系统的程序时，比如在C语言中使用*强制类型转换*(cast)来访问数据的字节序列时。  
### 2.1.4 表示字符串
以C语言为例，C语言中字符串被编码为一个以null字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是ASCII字符码。  
> 关于文字编码和Unicode编码  
ASCII编码字符集适合于编码英语文档，但是在表达一些特殊字符方面并没有太多办法，例如法语的“Ç”。它完全不适合编码希腊语、俄语、中文等语言的文档。  
于是Unicode联合会修订了最全面且广泛接受的文字编码标准。当前Unicode标准的字库包括将近100,000个字符、支持广泛的语言种类，包括古埃及和巴比伦文字。  
由于Unicode编码必须要使用4个字节，即32位比特来表示，为了减少占用的空间，出现了可变长的UTF-8编码，常见的字符只需要1个或2个字节，而不常用的需要多一些字节数。  
关于UTF-8编码的实现方式详见：[程序员趣味读物：谈谈Unicode编码](https://pcedu.pconline.com.cn/empolder/gj/other/0505/616631_all.html)  
### 2.1.5 表示代码
同样的程序的可执行文件在不同机器上的指令编码是完全不同的。不同的机器类型使用不同的且不兼容的指令和编码方式。因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。  
计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始程序的任何信息，除了可能有些用来帮助调试的辅助表以外。  

### 2.1.6 布尔代数简介  
1850年前后，乔治布尔注意到通过逻辑值TRUE(真)和FALSE(假)编码为二进制值1和0,能够设计出一种代数,以研究逻辑推理的基本原则.  
常用的布尔运算符有:NOT(~,!)，AND(&,∧) ，OR(|,∨)，XOR(^)  
具体规则不赘述.  

#### 布尔代数与布尔环 
布尔代数与整数运算有一些相似的地方(都满足环的定义),我们称长度为w的为向量上的^,&,|运算构成的环为布尔环(关于环的概念涉及很多,这里不展开).  
在布尔环中的"加法"逆元为^ ,即:对于任何布尔值a来说有:

```math
a \oplus a=0
```

这个结论可以扩展到位向量上,同时此性质即使重新组合顺序也依然成立,因此有:

```math
(a \oplus b) \oplus a=b
```

#### 位向量表示有限集合
我们可以用位向量[ a<sub>w-1</sub> , ... , a<sub>1</sub> , a<sub>0</sub> ]编码任何{ 0 , 1 , ... , w-1 }的子集,其中,当a<sub>i</sub> = 1时i属于这个子集.  
例如:我们可以用位向量a=[01101001]表示集合A = { 0 , 3 , 5 ,6 },用b=[01010101]表示集合B = { 0 , 2 , 4 , 6 }.使用这种编码集合的方法,布尔运算|和&分别对应于集合的并和交,而~对应于集合的补.  
上面的例子种a & b =[01000001], 得到A交B={ 0 , 6 }.

### 2.1.7 C语言中的位级运算
C语言支持位级布尔运算，具体有|，&，~，^运算符，分别代表或运算，与运算，取反运算和异或运算。这些运算能运用到任何“整形”的数据类型上。
> 一个运用位级运算的swap函数。  
> 
```
void inplace_swap(int *x,int *y)
{
    *y=*x^*y;
    *x=*x^*y;
    *y=*x^*y;
}
```
> 此方法实际上应用了上面所说的“加法”逆元。  
> 注意：这种交换方式实际上并没有性能上的优势(但是可以装逼)，它仅仅是一个智力游戏。

#### 掩码运算
利用C语言提供的位级运算，我们可以实现掩码运算（通过位级运算来从一个位向量中选出自己需要的位）。这与上面所说的位向量表示有限集合有一定相似之处。  
掩码0xFF(最低8位为1)表示一个字的低位自己，位级运算X&0xFF生成以一个由x的最低有效自己组成的值，其他字节就被置为0。  
关于如何生成全为1的掩码，除了直接用0XFFFFFFFF(使用此方法并不能保证移植性，在不同字长的机器上)外，可以使用~0，此方法产生的全1掩码受机器字长影响具有一定的移植性。
#### 掩码运算整理
我们有一个位向量x。那么有：

- x & ~ 0 = x
- x | ~ 0 = ~ 0
- x ^ ~ 0 = ~ x
- x & 0 = 0
- x | 0 = x
- x ^ 0 = x

### 2.1.8 C语言中的逻辑运算
C语言还提供了逻辑运算符:!、&&、||.
逻辑运算符和位级运算符的区别是，逻辑运算符认为所有非0的参数都表示TRUE，而参数0表示FALSE，表达式返回的值也是0或者1。
另一个区别是，如果第一个参数求职就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。
> 表达式`p&&*p++`不会导致简介引用空指针。

### 2.1.9 C语言中的移位运算
C语言中的移位运算分为左移和右移，右移又分为逻辑右移和算术右移。  
左移即把数据的二进制形式想做移动k位，右边用0补齐。  
右移分为逻辑右移和算术右移：  
逻辑右移往右移动k位，在左端补0。  
算术右移往右移动k为，在左端补原二进制数的最高位。  
操作|值
---|---
参数x|[01100011] [10010101]
x<<4|[0011**0000**] [0101**0000**]
x>>4(逻辑右移)|[**0000**0110] [**0000**1001]
x>>4(算术右移)|[**0000**0110] [**1111**1001]
C语言标准并没有明确规定队友有符号数应该使用哪种类型的右移——算术右移或者逻辑右移都可以，然而实际上，几乎所有的编译器/及其组合都对有符号数使用算术右移，且许多程序员也都假设机器会使用这种右移。另一方面，对于无符号数，右移必须是逻辑的。  
与C相比，Java对于如何进行右移有明确的规定。表达是x>>k将会是算术右移k个单位，而x>>>k会对x做逻辑右移。  
> 当移动k为时，k很大  
当对w位的二进制数据移动k位，且k大于w位时，实际移动的位数为k mod w  

## 2.2 整数表示
### 2.2.1无符号数的编码
其中有符号数的表示方法与传统二进制一致。  
假设有一个整数数据类型有w位。我们可以将位向量写成
```math
\vec x=[x_{w-1},x_{w-2},...,x_0]  
```
在这个编码中，每个x<sub>i</sub>都取值为0或1。我们用一个函数来表示B2U<sub>w</sub>来表示：  
```math
B2U_w(\vec x)=\sum_{i=0}^{w-1}x_i2^i 
```
无符号数的编码方式实际上与我们所知道的二进制编码方式是一致的。唯一要注意的是无符号数的编码具有唯一性，也就是说一个数字只能有一个无符号数编码。这是因为B2U<sub>w</sub>是一个双射。  
### 2.2.2有符号数的编码
有符号数的编码主要有三种方式：原码、补码与反码。我曾经写过一篇博客来进行探究，这里不赘述。  
[关于补码的由来和作用 ](https://www.cnblogs.com/z-y-k/p/11800932.html)  
需要说明的是：补码也具有唯一性，原码与反码不具备这种性质，因为0在原码与反码中有两种解释。  

### 2.2.3有符号数与无符号数之间的转换
#### 有符号数转无符号数 
C语言中提供了在不同数据类型中做强制类型转换的方法，对于无符号整数与有符号整数之间的转换方式，大多数系统上默认的是底层的位不变，由此我们能推出有符号数与无符号数之间的转换。
关于这些的转换的的过程和原理，在此不赘述。这里直接给出公式：  
一个数的编码方式从无符号编码(补码)转换为有符号编码后的数值公式为:  

```math
T2U_w(x)=\left\{
\begin{array}{rcl}
x+2^w       &      & {x<0}\\
x     &      & {x\geq0}\\
\end{array} \right.
```
如果有符号数的真值小于0那么，把真值加上2<sup>w</sup>即为其无符号真值，如果真值大于0，那么不变。  
我们用一段C语言代码举例：
```C
#include<stdio.h>
#include<stdlib.h>
#include<limits.h>
int main(void)
{
	int i = -1;
	unsigned int j = (unsigned int)i;
	printf("%u\n", j);
	printf("%u\n", UINT_MAX);
	system("pause");
}
```
VS2017下的运行结果：
![TIM截图20191117170002.png](https://i.loli.net/2019/11/17/ofThL82qmU93Akx.png)  
数据类型int的大小为8字节，32位，把-1转换成无符号数需要加上2<sub>32</sub>，结果为2<sub>32</sub>-1，正好为无符号数编码的最大值，所以与UINT_MAX的值一致。  
#### 无符号数转有符号数  
直接给出公式：

```math
U2T_w(u)=\left\{
\begin{array}{rcl}
u       &      & {u\leq TMAX_w}\\
u-2^w     &      & {u>TMAX_w}\\
\end{array} \right.
```
C语言代码测试实例：
```C
#include<stdio.h>
#include<stdlib.h>
#include<limits.h>
int main(void)
{
	unsigned int i = UINT_MAX;
	int j=(int)i;
	printf("%d", j);
	system("pause");
}
```
VS2017下的运行结果：
![TIM截图20191117172003.png](https://i.loli.net/2019/11/17/cxbwvCDXOyMSEs4.png)  
  
需要说明的是，在VS2017的环境下，上面两个程序经过测试即使不使用强制类型转换也可以得到正确的结果，其一是C语言中如果发现左右两边数据类型不一致会自动把数据往左边的类型转换，其二是，printf中的格式说明符也会自动执行类型转换，这里使用强制类型转换只是为了让转换看起来更加清晰。  

#### 无符号整数与有符号整数互相转换可能遇到的问题  
由于C语言对同时包含有符号和无符号数表达式的这种处理方式，出现了一些奇特的行为。当执行一个运算时**如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地把有符号参数强制类型转换为无符号，并假设这两个数都是非负的**。  
对于<和>这样的关系运算符来说，它会导致非直观的结果。我们同样用一个C语言程序来作为测试：  
```C
#include<stdio.h>
#include<stdlib.h>
int main(void)
{
	printf("%d", -1 < 0U);
	printf("%d",(unsigned)-1 > -2);
}
```
VS2017运行结果：  
![TIM截图20191117180823.png](https://i.loli.net/2019/11/17/nuHVNKqmvkE1oyd.png)  
第一个表达式中，由于0是无符号数，所以-1默认变成无符号数，即为2<sup>32</sup>-1,这个数必然比0要大。所以第一个表达式为假。  
第二个表达式中，通过把-1强制转换成无符号数，-1变为2<sup>32</sup>-1，-2变为2<sup>32</sup>-2，所以第二个表达式为真。  
### 2.2.4扩展一个数字的位表示
有时我们会把一个占用空间较小的数据类型转换为占用空间较大的数据类型(如果把占用空间较大的数据类型转换为占用空间较小的数据类型，可能会丢失数据，我们一般不推荐这么做)。  
#### 无符号数的零扩展
定义宽度为w位的位向量：
```math
\vec u=[u_{w=1},u_{w-2},...,u_0]
```
和宽度为w’的位向量：
```math
\vec u'=[0,...,0,u_{w-1},u_{w-2},...,u_{0}]
```
其中w'>w。则：
```math
B2U_w(\vec u)=B2U_{w'}(\vec u')
```
要将一个无符号数转换为一个更大的无符号数数据类型，我们只要简单的在前面加上足够的0即可，这种运算被称为零扩展。
#### 有符号数的符号拓展
定义宽度为w位的位向量：
```math
\vec x=[x_{w=1},x_{w-2},...,x_0]
```
和宽度为w’的位向量：
```math
\vec x'=[x_{w-1},...,x_{w-1},x_{w-1},x_{w-2},...,x_{0}]
```
其中w'>w。则：
```math
B2T_w(\vec x)=B2T_{w'}(\vec x')
```
要将补码数字转换为一个更大的数据类型，可以执行一个符号扩展(sign-extension)，在前面添加最高有效位的值。  
具体证明略。  
>值得注意的点：在C语言中，把类型不同、大小不同的两个数据类型相互转换，先改变数据类型的大小，然后在执行类型转换。  
>比如说：在C语言中，把一个short类型的变量转换为unsigned类型的变量，我们要先把short类型的变量扩展到8个字节，然后再执行有符号数到无符号数的转换。  
### 2.2.5截断数字
一些特殊情况下，尽管这样做会带来风险，但我们仍然有时候会需要把一个高位的数据类转换为低位的数据类型，这时候我们就需要截断这个数字。
#### 无符号数的截断
定义宽度为w位的位向量：
```math
\vec u=[u_{w-1},u_{w-2},...,u_0]
```
而它截断为k位的结果为：
```math
\vec u'=[u_{k-1},u_{k-2},...,u_{0}]
```
令x=B2U_w(\vec x),x'=B2U_(\vec x'),则x'=x mod 2^k。  
截断为k为实际上就是对原数的真值用2^k取模。具体证明过程略。  
#### 有符号数的截断
要理解有符号数的截断，我们首先要明白，无论是有符号数还是无符号数真正区别他们的不是他们的真值，而是他们的编码方式，实际上无论是有符号数，还是无符号数，在内存中都表示为串二进制数，有了编码对他们真值的解释，他们才能表示不同的数据。  
我们都知道，截断实际上就是截去前面冗余的位，只留下我们需要的位，既然无符号数和有符号数在内存中表示的方法实际上都是一串二进制数，我们为什么不可以把一个有符号数的位模式，看做是无符号数的编码，用无符号数的方式将其截断后得到的真值，再用把无符号数转换为有符号数，最终得到将有符号数阶段的真值。  
总而言之，有符号数编码的截断结果是:
```math
B2T_k[x_{k-1},x_{k-2},...,x_0]=U2T_k(B2U_w([x_{w-1},x_{w-2},...,x_0]) mod 2^k)
```

## 2.3整数运算
## 2.3.1无符号数运算
### 无符号数加法
考虑两个w为的无符号整数x、y，他们的编码范围都为[0,2<sup>w</sup>-1],那么x+y的范围为[0,2<sup>w+1</sup>-2],显然两个无符号数加法的结果是可能发生溢出的。  
为了舍弃多出来的位数，我们可以使用前面提到的截断的方法，把结果截断成w位就是溢出后舍弃进位的结果。  
我们将无符号加法表示为+<sup>u</sup><sub>w</sub>：  
```math
x+^u_wy=\left\{
\begin{array}{rcl}
x+y       &      & {x+y<2^w}(正常)\\
x+y-2^w     &      & {2^w \leq x+y < 2^{w+1}}(溢出)\\
\end{array} \right.
```
通常，说一个算术溢出，是指完整的整数结果不能放到数据类型的字长限制中去。
CSAPP中还给出了一个判断结果是否溢出的方法：
```math
对在范围0 \leq x,y\leq UMax_w中的x和y，令s=x+^u_wy。则对计算结果s，当且仅当s<x(或者等价地s<y)时，发生了溢出。  
```
### 无符号数求反
知道了加法后，我们只要知道一个数如何求反就能把加法化成减法：
```math
-^u_wx=\left\{
\begin{array}{rcl}
x      &      & {x=0}\\
2^w-x     &      & {x>0}\\
\end{array} \right.
```
求反或者说求加法逆元的方法就是让两个结果的和为0。
## 2.3.2补码运算
### 补码加法(有符号数)
给定两个w位的补码表示的有符号数x、y，范围为[-2<sup>w-1</sup>,2<sup>w-1</sup>-1],x+y的范围为[-2<sup>w</sup>,2<sup>w</sup>-2]，和有符号数一样准确表示这个范围的数需要w+1位的补码。  
另一方面，和截断一样，补码的加法和有符号数的加法其实从位模式上看也是一样的，将两个数相加后截断，然后将位模式解释为补码，得到的结果就是补码加法的结果：
 ```math
x+^t_wy=\left\{
\begin{array}{rcl}
x+y-2^w     &   &2^{w-1} \leq x+y(正溢出)\\
x+y       &      & {-2^{w-1} \leq x+y<2^{w-1}}(正常)\\
x+y+2^w     &      & {x+y < -2^{w-1}}(负溢出)\\
\end{array} \right.
```
同样的，CSAPP中也给出了一个判断结果是否溢出的方法:

```math
对满足TMin_w\leq x,y\leq TMax_w 的x和y,令s=x+^u_wy。当且仅当x>0,y>0,但s\leq 0时，计算s发生了正溢出，当且仅当x<0,y<0,但s\geq 0时发生了负溢出。
```
### 补码的非
和无符号数求反一样，补码的非实际上就是求加法逆元，这里直接给出公式：  
```math
-^t_wx=\left\{
\begin{array}{rcl}
TMin_w      &      & {x=TMin_w}\\
-x&      & {x>TMin_w}\\
\end{array} \right.
```
### 补码和无符号数编码都满足阿贝尔群
不能使用x+y-y==x的方法来判断x+y无论是否溢出，最后的结果都是x，这是因为补码和无符号数都满足阿贝尔群。

## 2.3.3无符号数和补码的乘法
和上面一样溢出就截断，补码可以先看成无符号编码，算出结果后转换成补码即可(无符号和补码乘法运算的位级表示都是一样的)，不赘述。
无符号乘法公式:
```math
x*^u_wy=(x•y) mod 2^w
```
补码乘法公式:
```math
x*^t_wy=U2T_w((x•y) mod 2^w)
```
## 2.3.4整数乘以常数
我们可以使用移位运算结合加法与减法进行整数与常数的乘法。  
原理为：**w位变量x<<k(0<=k<w)的值等于x * 2<sup>k</sup>**。  
即使移位后的结果产生溢出也不会影响最后的结果(如果溢出说明正常相乘的结果也会溢出)。  
而任何整数都可以由2的幂组合而成，故我们可以用移位结合加法来进行乘法运算，例如14可以写成14=2<sup>3</sup>+2<sup>2</sup>+2<sup>1</sup>。故x*14=(x<<3)+(x<<2)+(x<<1)。  
而对于一个形如[(0...0)(111)(0...0)]的位向量，考虑从位位置n到位位置m的连续的1(n>=m)。我们可以用2<sup>n+1</sup>-2<sup>m</sup>来代替2<sup>n</sup>+...+2<sup>m</sup>。例如对于14[(0...0)(111)(0)]来说,n=3,m=1,即14可以写作2<sup>4</sup>-2<sup>1</sup>，故x *14亦可以写作(x<<4)-(x<<1)。  
使用正常的乘法还是使用上述运用移位和加减的方法取决于这些指令的相对速度，当乘数的数额可以使用少量2的幂次相加或相减的得到时，我们(编译器)一般使用这种方法。  

## 2.3.5整数除以2的幂
和整数乘法一样，整数的除法也可以使用这一属性，但仅限于除以2的幂(书中并没有明确说明，但是右移代替除法会产生一定的误差，一次两次右移结果相加减可能没什么问题，多了的话误差肯定会越来越大，所以我估计用右移代替除法应该仅限于2的幂)。  
**w位变量x>>k(0<=k<w)的值等于[x / 2<sup>k</sup>] (向零取整)**。  
由于整数除法会产生小数位，我们需要把结果转换为整数，这就涉及到了**取整操作**。  
取整分为向上取整(⌈x⌉)和向下取整(⌊x⌋)，顾名思义，向上取整就是找比该数大的最小整数，向下取整就是找比该数小的最大整数。而整数除法则要求我们向零取整，即：如果该数大于0就向下取整，如果该数小于0就向上取整。  
- 对于无符号数右移(逻辑右移)，我们可以确定证明出其结果一定是向下取整的(证明过程略)。  
- 对于补码右移(算术右移)，正数右移和无符号数一样是向下取整的(证明过程略)。  
- 而对于补码的负数情况并不满足向零取整的要求---负数右移依然是向下取整的。  
- 为了解决这个问题我们需要在负数作除法时为其加上一个偏置(2<sup>k</sup>-1)。具体原理为对于整数x和y(y>0),⌈x/y⌉=⌊(x+y-1)/y⌋。这里的y为2<sup>k</sup>。
- 综上所述：对于使用算数右移的补码机器，C表达式为(x<0?x+(1<<k)-1:x)>>k。
