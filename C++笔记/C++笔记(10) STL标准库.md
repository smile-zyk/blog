# STL中的基本概念
- 容器：可容纳各种数据类型的通用数据结构，是类模板
- 迭代器：可用于依次存取容器中元素，类似与指针
- 算法：用来操作容器中的元素的函数模板

# 容器概述
可以用于存放各种类型的数据(基本类型的变量，对象等)的数据结构，都是类模板，分为三种：
1. 顺序容器 vector deque list
2. 关联容器 set multiset map multimap
3. 容器适配器 stack queue priority_queue

## 顺序容器简介
容器并非排序的，元素的插入位置同元素的值无关。
如vector deque list 三种
1. vector 头文件 <vector>
动态数组，元素在内存连续存放。随机存取任何元素通常在常数时间完成。在尾端增删元素具有较佳的性能。(大部分情况下是常数时间)
> vector容器是动态分配内存的，但其在分配内存是会预先多分配一些，所以大部分情况下在尾部插入元素只要O(1)的时间，只有在预先分配内存不够的时候，才会重新分配内存并拷贝O(N)。  
![QQ截图20200913133929.png](https://i.loli.net/2020/09/13/WzX4CVekRKqSyt8.png)

2. deque 头文件 <deque>
双向队列，元素在内存连续存放。随机存取任何元素都能在常数时间完成(仅次于vector)。在两端增删元素具有较佳的性能(大部分情况下是常数时间)。  
![QQ截图20200913134424.png](https://i.loli.net/2020/09/13/zkyOhvwFgA3uaNn.png)

3. list 头文件<list>
双向链表。元素在内存不连续存放，在任何位置增删元素都能在常数时间内完成。不支持随机存取。  
![QQ截图20200913134847.png](https://i.loli.net/2020/09/13/WLfEHwDgxhsuC1R.png)

## 关联容器简介
- 元素是排序的
- 插入任何元素，都按相应的排序规则来确定其位置
- 在查找时具有非常好的性能
- 通常以平衡二叉树方式实现，插入和检索的时间都是O(log(N))
1. set/multiset 头文件<set>  
set 即集合。set中不允许相同元素，multiset中允许存在相同的元素。
2. map/multimap 头文件<map>  
map与set的不同在于map中存放的元素有且仅有两个成员变量，一个名为first，另一个名为second，map根据first值对元素进行从小到大排序，并可快速地根据first来检索元素。
map同multimap的不同在于是否允许相同first值的元素。

## 容器适配器
1. stack 头文件<stack>  
栈。是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项(栈顶的项)。后进后出。  
![QQ截图20200913142950.png](https://i.loli.net/2020/09/13/DQJa4d6bpFCYuSX.png)
2. queue 头文件<queue>  
队列。插入只可以在尾部进行，删除、检索和修改只允许从头进行。先进先出。  
![QQ截图20200913143205.png](https://i.loli.net/2020/09/13/Ly6hiP8BxbnZdjC.png)
3. priority_queue 头文件<queue>
优先级队列。最高优先级元素总是第一个出列。

## 顺序容器和关联容器中都有的成员函数
- begin 返回指向容器中第一个元素的迭代器
- end 返回指向容器中最后一个元素后面的位置的迭代器
- rbegin 返回指向容器中最后一个元素的迭代器
- rend 返回指向容器中第一个元素前面的位置的迭代器
- erase 从容器中删除一个或几个元素
- clear 从容器中删除所有元素

## 顺序容器的常用成员函数
- front 返回容器中第一个元素的引用
- back 返回容器中最后一个元素的引用
- push_back 在容器末尾增加新元素
- pop_back 删除容器末尾的元素
- erase 删除迭代器指向的元素(可能会使该迭代器失效),或删除一个区间，返回被删除元素后面的那个迭代器。  

# 迭代器
- 用于指向顺序容器和关联容器中的元素
- 迭代器用法和指针类似
- 有const和非const两种
- 通过迭代器可以读取它指向的元素
- 通过非const迭代器还能修改其指向的元素
## 迭代器使用方法
- 声明方法：`容器类名::iterator 变量名;`或`容器类名::const_iterator`
- 解引用方法：`* 迭代器变量名`
### 反向迭代器
- 声明方法：`容器类名::reverse_iterator`
- 和正常迭代器区别：对反向迭代器使用++操作会使迭代器向前。
## 迭代器的类别
### 双向迭代器
若p和p1都是双向迭代器，则可对p、p1可进行以下操作:
- ++ p, p ++
- --p,p--
- *p
- p=p1
- p==p1,p!=p1、
### 随机访问迭代器
若p和p1都是随机访问迭代器,则可对p、p1可进行一下操作:
- 双向迭代器的所有操作
- p+=i 将p向后移动i个元素
- p-=i 将p向前移动i个元素
- p+i 值为:指向p后面的第i个元素的迭代器
- p-i 值为:指向p前面的第i个元素的迭代器
- p[i] 值为:p后面的第i个元素的引用
- p<p1,p<=p1,p>p1.p>=p1

## 不同容器的迭代器类别
![QQ截图20200913160605.png](https://i.loli.net/2020/09/13/WeMSu8C4UIjQPnr.png)  
> 注意：有的算法，例如sort，binary_search需要通过随机访问迭代器来访问容器中的元素，那么list以及关联容器就不支持该算法！  

# 算法
- 算法就是一个个函数模板，大多数在<algorithm>中定义
- STL中提供能在各种容器中通用的算法，比如查找，排序等
- 算法通过迭代器来操纵容器中的元素。许多算法可以对容器中的一个局部区间进行操作，因此需要两个参数，一个是起始元素的迭代器，一个是终止元素的后面一个元素的迭代器。比如，排序和查找。
- 有的算法返回一个迭代器。比如find()算法，在容器中查找一个元素，并返回一个指向该元素的迭代器
- 算法可以处理容器，也可以处理普通数组。  

## find算法
- 原型：`template<class Inlt,class T> Inlt find(Inlt first,Inlt last,const T& val);`
- first和last这两个参数都是容器的迭代器，它们给出了容器中的查找区间起点和终点[first,last)。区间的起点是位于查找范围之中的，而终点不是。
- 用==运算符判断相等
- 函数返回值是一个迭代器。如果找到，则该迭代器指向被找到的元素。如果找不到，则该迭代器等于last。  

## STL中"大""小"的概念
- 关联容器内部的元素是从小到大排序的
- 有些算法要求器操作的区间是从小到大排序的，称为"有序区间算法"，如:binary_search
- 有些算法会对区间进行从小到大排序，称为"排序算法"，如:sort
- 还有一些其他算法会用到"大""小"的概念。  
- 在使用STL时，在缺省的情况下，以下三个说法等价:
1. x比y小
2. 表达式"x<y"为真
3. y比x大

## STL中"相等"的概念
- 有时，"x和y相等"等价于"x==y为真"，例如未在排序区间上进行的算法，如顺序查找find...
- 有时"x和y相等"等价于"x小于y和y小于x同时为假"，例如：有序区间算法:如binary_search、关联容器自身的成员函数find