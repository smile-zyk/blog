# 第四周：运算符重载
## 基本概念
运算符重载，就是对已有的运算符(C++ 中预定义的运算符)赋予多重的含义，使同一运算符作用于不同类型的数据时导致不同类型的行为。  
运算符重载的目的是：扩展C++中提供的运算符的适用范围，使之能作用于对象。  
同一个运算符，对不同类型的操作数，所发生的行为不同。  
### 运算符重载的形式
1. 运算符重载的实质是函数重载。   
2. 可以重载为普通函数，也可以重载为成员函数。  
3. 把含运算符的表达式转换成对运算符函数的调用。  
4. 把运算符的操作数转换成运算符函数的参数。  
5. 运算符被多次重载时，根据实参类型决定调用哪个运算符函数。  
返回值类型 operator 运算符(形参表)  
{....  
}

注意：重载为成员函数是，参数个函数为运算符目数减一。  
重载为普通函数时，参数个数为运算符目数。  
## 运算符重载为友元函数  
一般情况下，将运算符重载为类的成员函数，是较好的选择。  
但有时，重载为成员函数不能满足使用要求，重载为普通函数，又不能访问类的私有成员，所以需要将运算符重载为友元。  
如加号的重载，使用时必须要保证对象在符号左侧，这显然与原有的符号有一定不同。  
因此我们可以把+重载为普通函数。同时将其设为要访问成员的友元。  
## 赋值运算符的重载
有时候我们希望赋值运算符两边的类型可以不匹配，比如，把一个int类型变量赋值给一个Complex对象，或把一个char *类型字符串赋值给一个字符串对象，此时就需要重载赋值运算符“=“。  
赋值运算符“=”只能重载为成员函数。  [为什么有的操作符重载函数只能是成员函数?](https://blog.csdn.net/qq_29344757/article/details/78820189
)
注意：初始化时调用的是复制构造函数，而不是运算符“=”：  
<pre>string s="hello"  //调用复制构造函数。
string s1("hello")  //调用复制构造函数。
s="world"  //调用运算符“=”。  
</pre>  
### 浅拷贝与深拷贝  
浅拷贝只是单纯的把两个对象的内容一致，并不能保证两个对象的成员指向的不同的地址，如果对象中的成员是地址，那么很容易造成两个对象的成员指向同一个地址。这种赋值我们称为浅拷贝，浅拷贝往往是不安全的。  
深拷贝保证两个对象的地址指向的内容一致，而不是对象的地址一致。  
对象缺省的赋值运算符一般执行浅拷贝，所以一般情况下我们要自己重载赋值构造函数。（对象的复制构造函数也是如此）  
关于浅拷贝深拷贝以及重载赋值运算符需要注意的问题详见：[=运算符重载应注意点](https://zhuanlan.zhihu.com/p/30217566)  
关于赋值运算符重载的返回值类型：  
对运算符进行重载的是后，好的风格是应该尽量保留运算符原本的特性  
为了支持这一特性并且支持a=b=c和(a=b)=c我们应该使用赋值左边的对象的引用作为返回类型。  
## 流插入运算符的重载  
iostream中重载了<<与>>运算符，其中有istream对象与ostream对象。  
为了能支持连续运算，流运算符需要返回相应引用。  
重载<<与>>运算符只能使用普通函数，因为iostrem对象已经在头文件中完成，无法再为它添加新的成员。  
##类型转换运算符的重载
任何类型的名字都是一个类型转换运算符（自定义类型？），其返回值都是本身的类型，比如double类型转换运算符的返回类型就是double本身。  
如：
<pre>operator double(){   //注意该类型转化运算符是成员函数，
      return real;
}</pre>
## 自增、自减运算符的重载  
自增运算符++、自减运算符--有前置/后置之分，为了区分所重载的是前置运算符还是后置运算符，C++规定：  
前置运算符作为一元运算符重载，后置运算符为二元运算符除了类型本身还有一个int。  
后置自增自减运算符返回类型为该对象改变前的实体。  
前置返回的是对象改变后的引用。  
一般来说前置运算符比后置运算符要快很多，因为后置运算符需要返回实体开销较大。  
## 关于运算符重载的其他注意点 ：
1.C++不允许定义新的运算符；  
2.重载后运算符的含义应该符合日常习惯；  
3.运算符重载不改变运算符的优先级；  
4.以下运算符不能重载："."、".*"、"::"、"?:"、sizeof;  
5.重载运算符()、[]、->或者赋值运算符，运算符重载函数必须声明为类的成员函数。