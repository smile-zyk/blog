# 第三周：类和对象提高
## this指针
### 作用
- this指针作用就是指向成员函数所作用的对象。  
- 非静态成员函数中可以直接使用this来代表指向该函数作用的指针。  
- 成员函数中默认有一个this指针指向当前对象，所以成员函数的真实参数个数需要+1。  

### 注意
静态成员函数中不能使用this指针！  
因为静态成员函数并不具体作用与某个对象！  
因此，静态成员函数的真实的参数的个数，就是程序中写出的参数个数！  
## 静态成员变量和静态成员函数
### 基本概念
静态成员：在说明前面加了static关键字的成员  
普通成员变量每个
对象有各自的一份，而静态成员变量一共就一份，为所有对象共享。 
普通成员函数必须具体作用与某个对象，而静态成员函数并不具体作用于某个对象，而静态成员函数并不具体作用于某个对象。  
因此静态成员不需要通过对象就能访问
静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在。
静态成员函数本质上是全局函数。
设置静态成员这种机制的目的是将和某些类紧密相关的全军变量和函数写到类里面，看上去像一个整体，易于维护和理解。  
### 如何访问
1. 类名::成员名  
2. 对象名.成员名  
3. 指正->成员名  
4. 引用.成员名  

静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义，实际上是给静态成员变量分配内存，否则不能使用，编译不会通过。  
### 注意事项
在静态成员函数中，不能访问非静态成员变量，也不能调用费静态成员函数。
## 初始化列表  
[c++中的初始化列表详解](https://blog.csdn.net/lws123253/article/details/80368047)
## 成员对象和封闭类
### 基本概念
- 有成员对象的类叫封闭类。  
- 任何生成封闭类对象的语句，都要让编译器明白，对象中的成员对象，是如何初始化的。  
具体的做法就是：通过封闭类的构造函数的初始化列表。  
- 成员对象初始化列表中的参数可以是任意复杂点的表达式，可以包括函数，变量，只要表达式中的函数或变量有定义就行。  

### 封闭类构造函数和析构函数的执行顺序
1. 封闭类对象生成，先执行所有对象成员的构造函数，然后才执行封闭类的构造函数。  
2. 对象成员的构造函数调用次序和对象成员在类中的说明次序一致，与它们在成员初始化列表中出现的次序无关。  
3. 当封闭类的对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数，次序和构造函数的调用次序相反。  

### 封闭类的默认复制构造函数
封闭类的默认构造函数会自动调用其成员对象的复制构造函数。
## 常量对象、常量成员函数和常引用
### 常量对象
如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加const关键字。  
常量对象不可被修改。  
常量对象上面不能执行非常量成员函数，即使其并没有改变对象。  
### 常量成员函数
在类的成员函数说明后面可以加const关键字，则该成员函数成为常量成员函数。  
常量成员函数执行期间不应修改其所作用的对象。因此，在常量成员函数中不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成员函数（静态成员函数除外）。  
### 常量成员函数的重载
两个成员函数，名字和参数表都一样，但是一个是const，一个不是，算重载。
### 常引用
见上上篇博客。
## 友元
友元分为友元函数和友元类两种
声明方法在声明前加一个friend即可。
### 友元函数
一个类的友元函数可以访问该类的私有成员。  
可以将一个类的成员函数（包括构造、析构函数）说明为另一个类的友元。
### 友元类
如果A是B的友元类，那么A的成员函数可以访问B的私有成员。
### 注意事项
友元类之间的关系不能传递，不能继承。