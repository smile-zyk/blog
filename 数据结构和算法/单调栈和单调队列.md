# 单调栈
单调栈主要解决：
- 在一个序列中寻找每个元素左边(右边)第一个最大值(最小值)的问题。
## 算法实现
从前往后遍历序列并一次把每个元素加入一个栈中，元素加入栈中需要保证，该元素的值要严格大于(小于)栈顶的值，这样得到的栈里面的元素一定是单调增(减)的，每个元素在插入时栈顶的值就是这个元素左边的最小(最大)值。

## 算法(不严谨)证明
> 仅证明求每个元素左边最小值的情况，其他的类似。  

设元素a<sub>i</sub>的左边有元素a<sub>j</sub>和a<sub>k</sub>(j<k<i)且这两个元素都在栈中，且a<sub>j</sub>>=a<sub>k</sub>，那么a<sub>i</sub>及其后面的元素左边的最小值一定不可能是a<sub>j</sub>，因为a<sub>k</sub>比a<sub>j</sub>小并且a<sub>k</sub>在a<sub>j</sub>的右边，我们没有必要存储一个不可能用到的值(a<sub>j</sub>)，因此我们要保证栈中的元素在k>j时保证a<sub>k</sub>>a<sub>j</sub>。

## 模板
### 题目描述
给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。

### 输入格式
第一行包含整数 N，表示数列长度。

第二行包含 N 个整数，表示整数数列。

### 输出格式
共一行，包含 N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。

### 数据范围
1≤N≤10^5  
1≤数列中元素≤109
### 输入样例：
5
3 4 2 7 5
### 输出样例：
-1 3 -1 2 2

### AC代码
```
#include<iostream>
using namespace std;
const int N=100010;
int n;
int st[N],top=-1;
int w[N];
int l[N];
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)cin>>w[i];
    for(int i=0;i<n;i++)
    {
        while(top!=-1&&st[top]>=w[i])top--;
        if(top==-1)l[i]=-1;
        else l[i]=st[top];
        st[++top]=w[i];
    }
    for(int i=0;i<n;i++)cout<<l[i]<<' ';
}
```

## 应用
### 题目描述
直方图是由在公共基线处对齐的一系列矩形组成的多边形。

矩形具有相等的宽度，但可以具有不同的高度。

例如，图例左侧显示了由高度为 2,1,4,5,1,3,3 的矩形组成的直方图，矩形的宽度都为 1：

![](https://www.acwing.com/media/article/image/2019/01/14/19_eac6c46017-2559_1.jpg)

通常，直方图用于表示离散分布，例如，文本中字符的频率。

现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。

图例右图显示了所描绘直方图的最大对齐矩形。

### 输入格式
输入包含几个测试用例。

每个测试用例占据一行，用以描述一个直方图，并以整数 n 开始，表示组成直方图的矩形数目。

然后跟随 n 个整数 h1，…，hn。

这些数字以从左到右的顺序表示直方图的各个矩形的高度。

每个矩形的宽度为 1。

同行数字用空格隔开。

当输入用例为 n=0 时，结束输入，且该用例不用考虑。

### 输出格式
对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。

每个数据占一行。

请注意，此矩形必须在公共基线处对齐。

### 数据范围
1≤n≤100000,
0≤hi≤1000000000
### 输入样例：
7 2 1 4 5 1 3 3   
4 1000 1000 1000 1000  
0
### 输出样例：
8  
4000
```
#include<iostream>
using namespace std;
const int N=100010;
int h[N],l[N],r[N];
int st[N],top=-1;
typedef long long LL;
int main()
{
    int n;
    while(cin>>n,n!=0)
    {
        h[0]=-1,h[n+1]=-1,top=-1;
        for(int i=1;i<=n;i++)cin>>h[i];
        for(int i=0;i<=n;i++)
        {
            while(top!=-1&&h[st[top]]>=h[i])top--;
            if(top!=-1)l[i]=st[top];
            st[++top]=i;
        }
        top=-1;
        for(int i=n+1;i>0;i--)
        {
            while(top!=-1&&h[st[top]]>=h[i])top--;
            if(top!=-1)r[i]=st[top];
            st[++top]=i;
        }
        LL res=0;
        for(int i=1;i<=n;i++)
            res=max(res,(LL)h[i]*(r[i]-l[i]-1));
        cout<<res<<endl;
    }
}
```
# 单调队列
单调队列主要解决:
- 滑动窗口求最大(最小值)

## 算法实现
> 滑动窗口求最大值  

维护一个双端队列，从前往后遍历元素依次入队，因为是滑动窗口所以要将超出窗口范围的值出队，入队时如果发现新入队的元素的值比队列中前面的值要大就说明前面的元素必不可能被选到，因为新入队的元素能存活的时间更长并且比他更优，所以要将它出队。这样维护出的队列一定是单调减的，那么队列头的元素一定是最大的。

## 模板题
### 题目描述
给定一个大小为 n≤10^6的数组。

有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。

你只能在窗口中看到 k 个数字。

每次滑动窗口向右移动一个位置。

以下是一个例子：

该数组为 [1 3 -1 -3 5 3 6 7]，k 为 3。
窗口位置|	最小值|	最大值
---|---|---
[1 3 -1] -3 5 3 6 7	|-1|	3
1 [3 -1 -3] 5 3 6 7	|-3|	3
1 3 [-1 -3 5] 3 6 7	|-3|	5
1 3 -1 [-3 5 3] 6 7	|-3|	5
1 3 -1 -3 [5 3 6] 7	|3|	6
1 3 -1 -3 5 [3 6 7]	|3|	7
你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。

### 输入格式
输入包含两行。

第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。

第二行有 n 个整数，代表数组的具体数值。

同行数据之间用空格隔开。

### 输出格式
输出包含两个。

第一行输出，从左至右，每个位置滑动窗口中的最小值。

第二行输出，从左至右，每个位置滑动窗口中的最大值。

### 输入样例：
8 3  
1 3 -1 -3 5 3 6 7
### 输出样例：
-1 -3 -3 -3 3 3  
3 3 5 5 6 7

```
#include<iostream>
using namespace std;

const int N=1000010;
int n,m;
int w[N];
int qu[N],hh=0,tt=-1;

int main()
{
    scanf("%d %d",&n,&m);
    for(int i=0;i<n;i++)scanf("%d",&w[i]);
    for(int i=0;i<n;i++)
    {
        if(hh<=tt&&i-m+1>qu[hh])hh++;
        while(hh<=tt&&w[qu[tt]]>=w[i])tt--;
        qu[++tt]=i;
        if(i-m+1>=0)cout<<w[qu[hh]]<<' ';
    }
    cout<<endl;
    hh=0,tt=-1;
    for(int i=0;i<n;i++)
    {
        if(hh<=tt&&i-m+1>qu[hh])hh++;
        while(hh<=tt&&w[qu[tt]]<=w[i])tt--;
        qu[++tt]=i;
        if(i-m+1>=0)cout<<w[qu[hh]]<<' ';
    }
}
```