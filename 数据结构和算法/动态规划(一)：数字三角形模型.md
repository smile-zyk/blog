# 数字三角形模型解决的一般问题
- 一般背景：在一个图中寻找条路径
- 求解：收益最大(最小)路径，费用最小路径
- 扩展：费用流问题(k个人同时出发总路径最小)

# 注意
- 初始化问题
- 边界问题

# 例题
## 1018. 最低通行费
一个商人穿过一个N×N的正方形的网格，去参加一个非常重要的商务活动。

他要从网格的左上角进，右下角出。

每穿越中间1个小方格，都要花费1个单位时间。

商人必须在(2N-1)个单位时间穿越出去。

而在经过中间的每个小方格时，都需要缴纳一定的费用。

这个商人期望在规定时间内用最少费用穿越出去。

请问至少需要多少费用？

注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。

### 输入格式
第一行是一个整数，表示正方形的宽度N。

后面N行，每行N个不大于100的整数，为网格上每个小方格的费用。

### 输出格式
输出一个整数，表示至少需要的费用。

### 数据范围
1≤N≤100
### 输入样例：
5  
1  4  6  8  10   
2  5  7  15 17   
6  8  9  18 20   
10 11 12 19 21   
20 23 25 29 33  
### 输出样例：
109
### 样例解释
样例中，最小值为109=1+2+5+7+9+12+19+21+33。
### 题目隐含条件：  
商人必须在(2N-1)个单位时间穿越出去。-> 商人只能往右或者往下走

### 状态转移
![QQ截图20210531142150.png](https://i.loli.net/2021/05/31/EXBYzSLen2JwRG6.png)  
### 代码
```
#include<iostream>
#include<cstring>
using namespace std;
const int N=110;

int f[N][N];
int w[N][N];

int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            cin>>w[i][j];
    memset(f,0x3f,sizeof f);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
            if(i==1&&j==1)f[i][j]=w[i][j];
            else 
            {
                if(i>1)f[i][j]=min(f[i][j],f[i-1][j]+w[i][j]);
                if(j>1)f[i][j]=min(f[i][j],f[i][j-1]+w[i][j]);
            }
        }
    cout<<f[n][n]<<endl;
}
```
## 1027. 方格取数
设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。如下图所示：

![](https://cdn.acwing.com/media/article/image/2019/09/12/19_764ece6ed5-2.gif)

某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。

在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。

此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。

### 输入格式
第一行为一个整数N，表示 N×N 的方格图。

接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。

行和列编号从 1 开始。

一行“0 0 0”表示结束。

### 输出格式
输出一个整数，表示两条路径上取得的最大的和。

### 数据范围
N≤10
### 输入样例：
8  
2 3 13  
2 6 6  
3 5 7  
4 4 14  
5 2 21  
5 6 4  
6 3 15  
7 2 14  
0 0 0  
### 输出样例：
67

### 代码
```
#include<iostream>
using namespace std;
const int N=30;

int f[N][N][N];
int w[N][N];

int main()
{
    int n;
    cin>>n;
    int a,b,c;
    while(cin>>a>>b>>c,a||b||c)
        w[a][b]=c;
    for(int k=2;k<=2*n;k++)
        for(int i1=1;i1<=n;i1++)
            for(int i2=1;i2<=n;i2++)
            {
                int j1=k-i1,j2=k-i2;
                if(j1>=1&&j1<=n&&j2>=1&&j2<=n)
                {
                    int t=w[i1][j1];
                    if(i1!=i2)t+=w[i2][j2];
                    int &x=f[k][i1][i2];
                    x=max(x,f[k-1][i1-1][i2-1]+t);
                    x=max(x,f[k-1][i1-1][i2]+t);
                    x=max(x,f[k-1][i1][i2-1]+t);
                    x=max(x,f[k-1][i1][i2]+t);
                }
            }
    cout<<f[2*n][n][n]<<endl;
}
```
